# Redis

## 数据结构

### String

内部的实现是通过 **SDS**（Simple Dynamic String ）来存储的。SDS 类似于 **Java** 中的 **ArrayList**，可以通过预分配冗余空间的方式来减少内存的频繁分配。通过`set`和`get`做简单的KV缓存。

**应用场景：**

- **缓存功能：**利用**Redis**作为缓存，配合其它数据库作为存储层，利用**Redis**支持高并发的特点，可以大大加快系统的读写速度、以及降低后端数据库的压力。
- **计数器：**快速实现计数和查询。最终的数据结果可以按照特定的时间写入数据库进行永久保存。
- **共享用户Session：**用户重新刷新一次界面，可能需要访问一下数据进行重新登录，或者访问页面缓存**Cookie**，但是可以利用**Redis**将用户的**Session**集中管理，每次用户**Session**的更新和获取都可以快速完成。大大提高效率。

### Hash

这个是类似 **Map** 的一种结构，这个一般就是可以将结构化的数据，比如一个对象（前提是**这个对象没嵌套其他的对象**）给缓存在 **Redis** 里，然后每次读写缓存的时候，可以就操作 **Hash** 里的**某个字段**。

### List

有序列表，可以存储表型数据结构，例如粉丝列表。比如可以通过 **lrange** 命令，读取某个闭区间内的元素，可以基于 **List** 实现分页查询，基于 **Redis** 实现简单的高性能分页，可以做类似微博那种下拉不断分页的东西，性能高，就一页一页走。

**应用场景：**

- **消息队列：**通过Redis的List实现消息队列。
- **文章列表或数据分页展示：**博客网站的文章列表，当用户量越来越多时，而且每一个用户都有自己的文章列表，需要分页展示，这时可以考虑使用**Redis**的列表，不但有序同时还支持按照范围内获取元素，可以完美解决分页查询功能。

### Set

无序集合，会自动去重。

可以利用HashSet去重，但如果应用部署在多台服务器上，可以用Redis进行全局去重。

### Sorted Set

**Sorted set** 是排序的 **Set**，去重还可以排序，写进去的时候给一个分数，自动根据分数排序。

**应用场景：**排行榜；实现带权重的队列，按优先级有序。

## 功能



## 淘汰策略



## Redis Cluster



## Key失效



## 数据持久化