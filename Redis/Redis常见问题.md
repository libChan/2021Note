# Redis

## 数据结构

### String

内部的实现是通过 **SDS**（Simple Dynamic String ）来存储的。SDS 类似于 **Java** 中的 **ArrayList**，可以通过预分配冗余空间的方式来减少内存的频繁分配。通过`set`和`get`做简单的KV缓存。

自增`incr`，自减`decr`，还可以设置步长；取string范围用`range`；替换用`setrange`；

一种key的设计：`user:{id}:{field}`，可以复用key，设置不同属性的值。

**应用场景：**

- **缓存功能：**利用**Redis**作为缓存，配合其它数据库作为存储层，利用**Redis**支持高并发的特点，可以大大加快系统的读写速度、以及降低后端数据库的压力。
- **计数器：**快速实现计数和查询。最终的数据结果可以按照特定的时间写入数据库进行永久保存。
- **共享用户Session：**用户重新刷新一次界面，可能需要访问一下数据进行重新登录，或者访问页面缓存**Cookie**，但是可以利用**Redis**将用户的**Session**集中管理，每次用户**Session**的更新和获取都可以快速完成。大大提高效率。

### Hash

这个是类似 **Map** 的一种结构，这个一般就是可以将结构化的数据，比如一个对象（前提是**这个对象没嵌套其他的对象**）给缓存在 **Redis** 里，然后每次读写缓存的时候，可以就操作 **Hash** 里的**某个字段**。

### List

有序列表，可以存储表型数据结构，例如粉丝列表。比如可以通过 **lrange** 命令，读取某个闭区间内的元素，可以基于 **List** 实现分页查询，基于 **Redis** 实现简单的高性能分页，可以做类似微博那种下拉不断分页的东西，性能高，就一页一页走。

可以实现栈、队列、阻塞队列（两端可以push pop）。从左边操作是L开头，比如`LPUSH`，从右边操作是R开头，`RPOP`。`LINDEX`可以按下标获取元素。

**应用场景：**

- **消息队列：**通过Redis的List实现消息队列。
- **文章列表或数据分页展示：**博客网站的文章列表，当用户量越来越多时，而且每一个用户都有自己的文章列表，需要分页展示，这时可以考虑使用**Redis**的列表，不但有序同时还支持按照范围内获取元素，可以完美解决分页查询功能。

### Set

无序集合，会自动去重。

可以利用HashSet去重，但如果应用部署在多台服务器上，可以用Redis进行全局去重。

### Sorted Set

**Sorted set** 是排序的 **Set**，去重还可以排序，写进去的时候给一个分数，自动根据分数排序。

**应用场景：**排行榜；实现带权重的队列，按优先级有序。

## 功能

**Bitmap**

位图是支持按 bit 位来存储信息，可以用来实现 **布隆过滤器（BloomFilter）**。

**布隆过滤器：**一种数据结构，对所有可能查询的参数以hash形式存储，在控制层（Redis缓存层前）先校验，不符合则丢弃，避免对底层存储系统的查询压力。

**HyperLogLog**

供不精确的去重计数功能，比较适合用来做大规模数据的去重统计，例如统计 UV。

**Geospatial**

可以用来保存地理位置，并作位置距离计算或者根据半径计算位置等。有没有想过用Redis来实现附近的人？或者计算最优地图路径？

**publish/subscribe**

功能是订阅发布功能，可以用作简单的消息队列。通过publish、subscribe等实现发布订阅功能，redis-server维护一个字典，channel是key，value是订阅者链表。

**缺点：**在消费者下线的情况下，生产的消息会丢失，得使用专业的消息队列如**RocketMQ**等。

**Pipeline**

可以批量执行一组指令，一次性返回全部结果，可以减少频繁的请求应答。前提是**pipeline**执行的指令之间没有因果相关性。

**Lua**

**Redis** 支持提交 **Lua** 脚本来执行一系列的功能。

## 淘汰策略

**定期删除+惰性删除！**

**定期删除：**默认100ms就**随机抽**一些设置了过期时间的key，去检查是否过期，过期了就删除。

**惰性删除：**等到查询时检查是否过期了，过期就删除且缓存不命中。

定期删除和惰性删除没有清理？内存淘汰机制：

官网上给到的内存淘汰机制是以下几个：

- **no-eviction**:返回错误当内存限制达到并且客户端尝试执行会让更多内存被使用的命令（大部分的写入指令，但DEL和几个例外）

- **allkeys-lru**: 尝试回收最少使用的键（LRU），使得新添加的数据有空间存放。

- **volatile-lru**: 尝试回收最少使用的键（LRU），但仅限于在过期集合的键,使得新添加的数据有空间存放。

- **allkeys-random**: 回收随机的键使得新添加的数据有空间存放。

- **volatile-random**: 回收随机的键使得新添加的数据有空间存放，但仅限于在过期集合的键。

- **volatile-ttl**: 回收在过期集合的键，并且优先回收存活时间（TTL）较短的键,使得新添加的数据有空间存放。

  如果没有键满足回收的前提条件的话，策略**volatile-lru**, **volatile-random**以及**volatile-ttl**就和**noeviction**差不多了。

## Redis集群

### 主从复制

将一台Redis服务器（主节点，master/leader）的数据复制到其他Redis服务器（从节点，slave/follower）。

主从复制，读写分离。主只能写，从只能读，Redis集群最少一主二从。

**主从复制的作用：**

1、数据冗余：数据热备份，除持久化外的一种冗余方式。

2、故障恢复：主节点出现问题，从节点可以提供服务，快速故障恢复。

3、负载均衡：主写从读，分担负载。写少读多的场景，提高并发量。

4、高可用（集群）基石：主从复制是哨兵和集群能够实现的基础，所以是高可用的基础。

**复制原理**：

slave连接到master后会发送一个sync同步命令，master启动后台的存盘进程，收集所有修改命令，将传送整个数据文件到到slave，这是一次全量复制。

全量复制：slave接收到数据库文件数据后，存盘并加载到内存中。

增量复制：将新的修改命令同步到slave。

只要是重连到master，都要执行一次全量复制。

### 哨兵模式

监控主机是否故障，如果故障了根据投票数自动将slave转换为master。哨兵是一个独立的进程，通过发送命令，等待redis服务器响应。单机哨兵可能出现问题，采用多机哨兵互相监控。

假设master宕机，哨兵1先检测到，但不会马上进行故障转移，这只是哨兵1的**主观下线**，当其他哨兵也检测到，且数量达到阈值，哨兵之间会进行投票，进行故障转移操作。高票的当选master，切换成功后，通过发布订阅，让slave切换主机，这个过程是**客观下线**。

### 缓存穿透和雪崩

**缓存穿透：**用户查询数据redis缓存不命中，再向数据库查询，数据库内也没有。但当用户很多的高并发场景，数据库压力很大，出现了缓存穿透的现象。

**解决方案：**

1、布隆过滤器

2、缓存空对象，查数据库不命中即使返回空对象也缓存起来，设置一个过期时间，临时保护后端DB。可能存在的问题：很多<key, null>；即使对空值设置了过期时间，还是会存在缓存和DB时间不一致的情况，对需要保持一致性的业务有影响。

**缓存击穿：**一个热key在抗大并发，当这个key失效的瞬间，大并发直接请求数据库，DB压力过大。

**解决方案：**

1、热点数据永不过期

2、加互斥锁：分布式锁，保证对每个key同时只有一个线程去查询后端服务，其他线程等待。压力转到了分布式锁上。

**缓存雪崩：**某个时间段，缓存集中过期失效。比如双十一零点大量商品缓存，但1点时这批商品缓存过期，对它们的查询都落到了DB上，出现波峰。

集中过期的雪崩不是非常致命，但如果是某个服务器节点宕机，形成自然雪崩，对DB的压力是不可预测的，可能瞬间击垮DB。

**解决方案：**

1、Redis高可用：多几台机器

2、限流降级：缓存失效后，通过加锁或者队列来控制读DB写缓存的线程数。

3、数据预热：正式部署前，把可能的数据预先访问一边，大量数据加载到缓存中。在即将发生大并发访问前，手动出发加载缓存不同的key，设置不同的过期时间，防止集中过期。

### 分布式锁

跨JVM的互斥机制，控制共享资源的访问。

实现方案：基于DB、缓存（Redis），Zookeeper。

`setnx`加锁，`del`释放锁，`expire`设置过期时间，加锁和设置过期时间需要保证原子性，使用原子命令`set lock nx ex time `同步进行加锁和设置过期时间。

## 数据持久化

**Redis** 提供了 **RDB （全量）**和 **AOF （增量）**两种持久化方式，RDB 是把内存中的数据集以快照形式写入磁盘，实际操作是通过 fork 子进程执行，然后copy-on-write，采用二进制压缩存储。**AOF** 机制对每条写入命令作为日志，以 **append-only** 的模式写入一个日志文件中，

RDB会耗费较长时间，不够实时，在停机的时候会导致大量丢失数据，所以需要AOF来配合使用。在redis实例重启时，会使用RDB持久化文件重新构建内存，再使用AOF重放近期的操作指令来实现完整恢复重启之前的状态。

Redis本身的机制是 AOF持久化开启且存在AOF文件时，优先加载AOF文件；否则，加载RDB文件；加载AOF/RDB文件后，Redis启动成功；如果AOF/RDB文件存在错误时，Redis启动失败并打印错误信息。**优先AOF是因为AOF的数据是比RDB更完整的。**

**RDB优点：**

生成数据集快照，很适合做**冷备**。比如数据运维设置定时任务，定时同步到远端的服务器，比如阿里的云服务，这样一旦线上挂了，你想恢复多少分钟之前的数据，就去远端拷贝一份之前的数据就好了。

**RDB**对**Redis**的性能影响非常小，是因为在同步数据的时候他只是**fork**了一个子进程去做持久化的，而且他在数据恢复的时候速度比**AOF**快。

**RDB缺点：**

**RDB**都是快照文件，都是默认五分钟甚至更久的时间才会生成一次，这段时间的数据可能丢掉。**AOF**则最多丢一秒的数据，**数据完整性**上高下立判。

还有就是**RDB**在生成数据快照的时候，如果文件很大，客户端可能会暂停几毫秒甚至几秒，你公司在做秒杀的时候他刚好在这个时候**fork**了一个子进程去生成一个大快照，gg。

**AOF优点：**

**AOF**是一秒一次去通过一个后台的线程`fsync`操作，那最多丢这一秒的数据。

**AOF**在对日志文件进行操作的时候是只是追加的方式写，少了很多磁盘寻址的开销，写入性能惊人，文件也不容易破损。

**AOF**的日志是通过一个叫**非常可读**的方式记录的，这样的特性就适合做**灾难性数据误删除**的紧急恢复了，比如误**flushall**清空了所有的数据，只要这个时候后台重写还没发生，马上拷贝一份**AOF**日志文件，把最后一条**flushall**命令删了就可以。

**AOF缺点：**

一样的数据，**AOF**文件比**RDB**还要大。**性能比RDB低。**

## 高可用



## Q&A

**Q：假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如何将它们全部找出来？**

> 使用**keys**指令可以扫出**指定模式**的key列表。

**Q：如果redis正在给线上的业务提供服务，那使用keys指令会有什么问题？**

> Redis的单线程的。keys指令会导致线程阻塞一段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复。这个时候可以使用**scan**指令，**scan**指令可以无阻塞的提取出指定模式的key列表，但是会有一定的重复概率，在客户端做一次去重就可以了，但是整体所花费的时间会比直接用keys指令长。

**Q：Redis为什么快？**

> **Redis**采用的是**基于内存的**采用的是**单进程单线程模型**的 KV 数据库，C语言编写。
>
> - 完全**基于内存**，数据存在内存中，类似于**HashMap**，查找和操作的时间复杂度都是O(1)。
> - 数据结构简单，对数据操作也简单。
> - 采用**单线程**，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 **CPU**，不用去考虑各种锁的问题，不存在加锁释放锁操作。
> - 使用多路I/O复用模型，非阻塞IO。
> - 使用底层模型不同，它们之间底层实现方式以及与客户端之间通信的应用协议不一样，**Redis**直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。

**Q：缓存更新方式？**

> 缓存的数据在数据源发生变更时需要对缓存进行更新，数据源可能是 DB，也可能是远程服务。更新的方式可以是主动更新。
>
> **数据源是 DB 时**，可以在**更新完 DB 后就直接更新缓存**。
>
> 当**数据源**不是 DB 而是**其他远程服务**，可能无法及时主动感知数据变更，这种情况下一般会选择**对缓存数据设置失效期**，也就是数据不一致的最大容忍时间。
>
> 这种场景下，可以选择**失效更新**，key 不存在或失效时先请求数据源获取最新数据，然后再次缓存，并更新失效期。
>
> 但这样做有个问题，**如果依赖的远程服务在更新时出现异常**，则会导致数据不可用。改进的办法是异步更新，就是当失效时先不清除数据，继续使用旧的数据，然后由异步线程去执行更新任务。这样就避免了失效瞬间的空窗期。另外还有一种纯异步更新方式，定时对数据进行分批更新。实际使用时可以根据业务场景选择更新方式。

**Q：数据不一致？**

> 缓存不一致产生的原因一般是主动更新失败，例如更新 DB 后，更新 **Redis** 因为网络原因请求超时；或者是异步更新失败导致。
>
> 解决的办法是，如果**服务对耗时不是特别敏感可以增加重试**；如果**服务对耗时敏感可以通过异步补偿任务来处理失败的更新**，或者短期的数据不一致不会影响业务，那么只要下次更新时可以成功，能保证最终一致性就可以。

**Q：缓存不一致？**

> [缓存一致性问题怎么解决？](https://mp.weixin.qq.com/s/dYvM8_6SQnYRB6KjPsprbw)
>
> **删除缓存有两种方式：**
>
> 1. 先删除缓存，再更新数据库。解决方案是使用延迟双删。
> 2. 先更新数据库，再删除缓存。解决方案是消息队列或者其他binlog同步，引入消息队列会带来更多的问题，并不推荐直接使用。
>
> 针对缓存一致性要求不是很高的场景，那么只通过设置超时时间就可以了。
