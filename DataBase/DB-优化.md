# DB-优化

[TOC]

## 1. 定位、分析低效SQL语句

### 1.1 定位低效SQL语句

- 通过**慢查询日志定位执行效率低的SQL语句**，将slow-query-log参数设置为1，MySQL会将执行时间超过设定阈值的SQL写入指定文件。
- 慢查询日志在查询结束后才能查看记录。当查询正在执行时，可使用命令`show processlis`命令查看MySQL当前的线程状态、是否锁表、SQL执行情况等。

### 1.2 EXPLAIN分析SQL执行计划

定位到低效的SQL语句后，可以通过`EXPLAIN`或`DESC`命令获取MySQL如何执行select语句的信息。

explain命令的返回信息：

- select_type：select的类型，常见SIMPLE（简单表），PRIMARY（主查询，外层查询），UNION（UNION后面的查询）等
- table：要查询的表
- **type：**MySQL在表中找到记录的方式（访问类型）

```
ALL < index < range < ref < eq_ref < const,system < NULL
从左到右，性能由差到好
const：使用主键或者唯一索引进行查询的时候只有一行匹配 ref：使用非唯一索引 range：使用主键、单个字段的辅助索引、多个字段的辅助索引的最后一个字段进行范围查询 index：和all的区别是扫描的是索引树 all：扫描全表。
```

- possible_keys：查询时可能使用的索引
- **key：**实际使用的索引
- **rows：**扫描行的数量（预估值）

### 1.3 show profile分析SQL

执行完sql语句后，profile可以查看每个查询的时间，详细情况。mysql5.6后通过trace文件进一步展示优化器如何选择执行计划。

**MySQL5.7中，profile不建议使用，而通过`performance schema`中的性能视图来替代。**

### 1.4 trace分析优化器的执行计划

通过trace文件能进一步了解为什么优化器选择A执行计划而不选B计划，有助于更好的理解优化器的行为。 

### 1.5 SQL优化

#### 1.5.1 查询SQL优化

####################索引优化，待补充。####################

#### 1.5.2 优化 INSERT

- **同时从同一客户插入很多行，尽量使用多个值表的INSERT语句。**缩减客户端与数据库之间的连接，关闭等消耗。例如：

```sql
insert int test values(1,2), (1,3), (1,4);
```

#### 1.5.3 优化 ORDER BY

**MySQL有两种排序方式：**

1. 通过有序索引顺序扫描直接返回有序数据。explain分析查询可以发现使用索引，无需额外排序，操作效率高。
2. 通过对返回数据进行排序，就是FileSort排序。优化策略：尽量减少额外FileSort，通过索引返回有序数据。where条件和order by使用相同索引，并且order by的顺序和索引顺序相同，并且order by的字段都是升序或降序，否则需要在索引上进行额外排序工作。

**无法避免FileSort时：**

FileSort有两种排序算法：内排序（一趟扫描算法），外排序（两趟扫描算法）。

- 适当增大内排序允许使用的内存空间（调整参数），使用内排。
- 尽量使用必要字段，减少`select *`的使用。

#### 1.5.4 优化 GROUP BY

MySQL对所有GROUP BY的字段进行排序。如果想要避免排序，可以在GROUP BY后指定ORDER BY NULL，禁止排序。如：

```sql
select ... group by age order by null
```

#### 1.5.5 优化 JOIN

> MySQL对于多表JOIN目前只支持Nested-loop Join(NLJ)。（这句话有待考量。。）

NLJ的原理：内外两层循环，对外循环的每条记录，在内循环中做一次检索。外循环表成为驱动表。那么NLJ的性能主要取决于：

- 外循环结果集的大小
- 内循环扫描的效率

相对应的优化策略是：

- 在外循环驱动表上加where和合适的索引，使结果集更小
- 在关联字段上加索引

By the way, 可以将嵌套查询

#### 1.5.6 使用直方图

利用直方图，用户可以对一张表的一列数据做数据分布的统计。由于一些字段的数据分布不均衡，导致优化器对某些值不会选择最优的执行计划。创建直方图，使优化器了解条件列中具体的数据分布情况。

## 1. Oracle SQL优化

- ==选择最高效的表名顺序==

DB的解析器**从右到左**顺序处理`FROM`子句中的表名。

3个表毫无关系：记录和列名最少的表写最后。

3个表以上的连接查询：引用最多的表放在最后。

- ==where子句中的连接顺序==

**从右向左**解析where子句。表之间的连接靠左（=），可以过滤大量记录的条件靠右写。

- ==select子句中避免使用*号==

*可以获得全部属性数据（完整的一行），**但要通过查询数据字典完成，耗费大量时间**。

- ==truncate替代delete==

删除整个表的内容，保留表结构时，首选truncate，delete慢。

- ==使用内部函数提高SQL效率==

**例如使用mysql的concat()函数会比使用||来进行拼接快，因为concat()函数已经被mysql优化过了。**

- ==善用索引==

当表非常大时（记录量大），使用索引。

- ==避免在索引列上使用计算==

WHERE子句中，**如果索引列是函数的一部分，优化器将不使用索引而使用全表扫描，这样会变得变慢**

- ==用`>=`替代`>`==

比如`where num > 3`和`where num >= 4`。==？？？？？==

- ==用IN替代OR==
- ==where中使用索引的第一个列查询==

如果索引是建立在多个列上，只有在它的第一个列被WHERE子句引用时，优化器才会选择使用该索引。 当只引用索引的第二个列时，不引用索引的第一个列时，优化器使用了全表扫描而忽略了索引。

```sql
create index emp_sal_job_idex
on emp(sal,job);
----------------------------------
select *
from emp  
where job != 'SALES';    

上边就不使用索引了。
```

## 2. 结构优化

- 范式优化：消除冗余（节省空间）
- 反范式优化：适当增加冗余（减少表连接）
- 拆分表：垂直拆分，水平拆分

## 3. 常见SQL优化策略

1. 对查询进行优化，要尽量**避免全表扫描**，首先应**考虑在 where 及 order by 涉及的列上建立索引**。任何在Order by语句的非索引项或者有计算表达式都将降低查询速度
2. 应尽量**避免在 where 子句中对字段进行 null 值判断**，否则将导致引擎放弃使用索引而进行全表扫描，如`select id from t where num is null`。任何在where子句中使用is null或is not null的语句优化器是不允许使用索引的。
3. **最好不要给数据库留NULL**，尽可能的使用 NOT NULL填充数据库.NULL值也是可能会需要占用空间的，一些定长的数据类型即使数据为NULL也是会占用空间的。
4. 应尽量**避免在 where 子句中使用 != 或 <> 操作符**，否则将引擎放弃使用索引而进行全表扫描。
5. **应尽量避免在 where 子句中使用 or 来连接条件**，如果一个字段有索引，一个字段没有索引，将导致引擎放弃使用索引而进行全表扫描，可以使用union/union all 代替
6. **in 和 not in 也要慎用，否则会导致全表扫描**。一般情况下，当你IN中的条件太多，或是无法估计时，优化器倾向于全表扫描。当IN的条件少时，如果优化器认为，INDEX SEEK可以带来好处时，照样会走索引的。至于in到底会不会走索引，这个众说纷纭，网上有一种说法：（1）**A IN(值列表)肯定用索引**、（2）**A in (子查询) 是用不到索引的，但是如果子查询的条件是和外层相关的，子查询本身用到索引**。但是第一种有个情况，**就是如果一个列的值只有有限的几种，那么A IN （值列表）也是不会使用索引的**，因为这种情况，全表扫描比走索引快，优化器会选择走全表扫描的。至于not in 是一个反向查询，是不会走索引的。
7. **慎用like用于模糊查询，因为其可能导致全表扫描**，使用like语句，仅仅后模糊查询是可以走索引的(如：`like '56%'`)，但是前模糊查询会全表扫描(如`like '%we' 或 like '%we%'`)
8. **如果在 where 子句中使用参数，也会导致全表扫描。**因为SQL只有在运行时才会解析局部变量，但优化程序不能将访问计划的选择推迟到运行时；它必须在编译时进行选择。然 而，如果在编译时建立访问计划，变量的值还是未知的，因而无法作为索引选择的输入项。如下面语句将进行全表扫描：`select id from t where num = @num` 可以改为强制查询使用索引：`select id from t with(index(索引名)) where num = @num`
9. 应尽量**避免在 where 子句中对字段进行表达式操作**，这将导致引擎放弃使用索引而进行全表扫描。如：`select id from t where num/2 = 100`可以改为`select id from t where num = 100*2`
10. 应尽量**避免在where子句中对字段进行函数操作**，这将导致引擎放弃使用索引而进行全表扫描。如：`select id from t where datediff(day,createdate,’2005-11-30′) = 0`
11. 不要在 where 子句中的“=”**左边进行函数、算术运算或其他表达式运算**，否则系统将可能无法正确使用索引。
12. 在使用索引字段作为条件时，如果该索引是复合索引，那么必须使用到该索引中的第一个字段作为条件时才能保证系统使用该索引，否则该索引将不会被使用，并且应尽可能的让字段顺序与索引顺序相一致。
13. Update 语句，如果只更改1、2个字段，不要Update全部字段，否则频繁调用会引起明显的性能消耗，同时带来大量日志
14. 对于多张大数据量（这里几百条就算大了）的表JOIN，**要先分页再JOIN**，否则逻辑读会很高，性能很差
15. select count(*) from table；这样不带任何条件的count会引起全表扫描，并且没有任何业务意义，是一定要杜绝的。
16. **索引并不是越多越好**，索引固然可以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率，因为 insert 或 update 时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。**一个表的索引数最好不要超过5个**，若太多则应考虑一些不常使用到的列上建的索引是否有 必要。

## 4.SQL执行顺序

```
(7)     SELECT 
(8)     DISTINCT <select_list>
(1)     FROM <left_table>
(3)     <join_type> JOIN <right_table>
(2)     ON <join_condition>
(4)     WHERE <where_condition>
(5)     GROUP BY <group_by_list>
(6)     HAVING <having_condition>
(9)     ORDER BY <order_by_condition>
(10)    LIMIT <limit_number>
```

![img](https://images2015.cnblogs.com/blog/690102/201607/690102-20160714101317482-683714239.png)

## 5. 分库分表

**为什么分库分表？**

数据库出现性能瓶颈，例如大量请求阻塞、SQL变慢、存储问题等。

**软件层面调优：**SQL调优、表结构优化、读写分离、数据库集群、分库分表。

**表结构优化：**例如冗余字段减少join等，但也会带来更新时需要对多个表进行更新，故倾向于选择不常更新的冗余字段。

**分库：**应用的不同模块使用的DB拆开，如果只拆应用模块不拆DB的话，性能瓶颈还是不能解决。分库是解决DB层面的性能问题。

**分表：**水平拆分拆量（按时间），垂直拆分拆属性，表结构变了。分表是解决单表查询时的性能问题。

**分库分表带来的复杂性：**

- 跨库关联查询：比如两张表在不同库中如何join？字段冗余、数据抽象成新表、全局表等等。
- 分布式事务：多数据库分布式事务，基于可靠消息、两阶段事务提交、柔性事务等。
- 排序、分页、函数计算问题：采用分片思路，再merge各个片的结果。
- 分布式ID：单库单表可以用自增主键，分库分表后需要用全局唯一ID，例如Snowflake算法。

