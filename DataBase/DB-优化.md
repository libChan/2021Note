# DB-优化

[TOC]

## 1. 定位、分析低效SQL语句

### 1.1 定位低效SQL语句

- 通过慢查询日志定位执行效率低的SQL语句，将slow-query-log参数设置为1，MySQL会将执行时间超过设定阈值的SQL写入指定文件。
- 慢查询日志在查询结束后才能查看记录。当查询正在执行时，可使用命令`show processlis`命令查看MySQL当前的线程状态、是否锁表、SQL执行情况等。

### 1.2 EXPLAIN分析SQL执行计划

定位到低效的SQL语句后，可以通过`EXPLAIN`或`DESC`命令获取MySQL如何执行select语句的信息。

explain命令的返回信息：

- select_type：select的类型，常见SIMPLE（简单表），PRIMARY（主查询，外层查询），UNION（UNION后面的查询）等
- table：输出结果集的表
- **type：**MySQL在表中找到记录的方式（访问类型）

```
ALL < index < range < ref < eq_ref < const,system < NULL
从左到右，性能由差到好
```

- possible_keys：查询时可能使用的索引
- **key：**实际使用的索引
- **rows：**扫描行的数量（预估值）

### 1.3 show profile分析SQL

执行完sql语句后，profile可以查看每个查询的时间，详细情况。mysql5.6后通过trace文件进一步展示优化器如何选择执行计划。

**MySQL5.7中，profile不建议使用，而通过`performance schema`中的性能视图来替代。**

### 1.4 trace分析优化器的执行计划

通过trace文件能进一步了解为什么优化器选择A执行计划而不选B计划，有助于更好的理解优化器的行为。 

### 1.5 SQL优化

#### 1.5.1 查询SQL优化

####################索引优化，待补充。####################

#### 1.5.2 优化 INSERT

- **同时从同一客户插入很多行，尽量使用多个值表的INSERT语句。**缩减客户端与数据库之间的连接，关闭等消耗。例如：

```sql
insert int test values(1,2), (1,3), (1,4);
```

#### 1.5.3 优化 ORDER BY

**MySQL有两种排序方式：**

1. 通过有序索引顺序扫描直接返回有序数据。explain分析查询可以发现使用索引，无需额外排序，操作效率高。
2. 通过对返回数据进行排序，就是FileSort排序。优化策略：尽量减少额外FileSort，通过索引返回有序数据。where条件和order by使用相同索引，并且order by的顺序和索引顺序相同，并且order by的字段都是升序或降序，否则需要在索引上进行额外排序工作。

**无法避免FileSort时：**

FileSort有两种排序算法：内排序（一趟扫描算法），外排序（两趟扫描算法）。

- 适当增大内排序允许使用的内存空间（调整参数），使用内排。
- 尽量使用必要字段，减少`select *`的使用。

#### 1.5.4 优化 GROUP BY

MySQL对所有GROUP BY的字段进行排序。如果想要避免排序，可以在GROUP BY后指定ORDER BY NULL，禁止排序。如：

```sql
select ... group by age order by null
```

#### 1.5.5 优化 JOIN

> MySQL对于多表JOIN目前只支持Nested-loop Join(NLJ)。（这句话有待考量。。）

NLJ的原理：内外两层循环，对外循环的每条记录，在内循环中做一次检索。外循环表成为驱动表。那么NLJ的性能主要取决于：

- 外循环结果集的大小
- 内循环扫描的效率

相对应的优化策略是：

- 在外循环驱动表上加where和合适的索引，使结果集更小
- 在关联字段上加索引

By the way, 可以将嵌套查询

#### 1.5.6 使用直方图

利用直方图，用户可以对一张表的一列数据做数据分布的统计。由于一些字段的数据分布不均衡，导致优化器对某些值不会选择最优的执行计划。创建直方图，使优化器了解条件列中具体的数据分布情况。

（直方图中的过滤因子，还没搞懂）

## 1. Oracle SQL优化

- ==选择最高效的表名顺序==

DB的解析器**从右到左**顺序处理`FROM`子句中的表名。

3个表毫无关系：记录和列名最少的表写最后。

3个表以上的连接查询：引用最多的表放在最后。

- ==where子句中的连接顺序==

**从右向左**解析where子句。表之间的连接靠左（=），可以过滤大量记录的条件靠右写。

- ==select子句中避免使用*号==

*可以获得全部属性数据（完整的一行），**但要通过查询数据字典完成，耗费大量时间**。

- ==truncate替代delete==

删除整个表的内容，保留表结构时，首选truncate，delete慢。

- ==使用内部函数提高SQL效率==

**例如使用mysql的concat()函数会比使用||来进行拼接快，因为concat()函数已经被mysql优化过了。**

- ==善用索引==

当表非常大时（记录量大），使用索引。

- ==写大写==

- ==避免在索引列上使用计算==

WHERE子句中，**如果索引列是函数的一部分，优化器将不使用索引而使用全表扫描，这样会变得变慢**

- ==用`>=`替代`>`==

比如`where num > 3`和`where num >= 4`。==？？？？？==

- ==用IN替代OR==
- ==where中使用索引的第一个列查询==

如果索引是建立在多个列上，只有在它的第一个列被WHERE子句引用时，优化器才会选择使用该索引。 当只引用索引的第二个列时，不引用索引的第一个列时，优化器使用了全表扫描而忽略了索引。

```sql
create index emp_sal_job_idex
on emp(sal,job);
----------------------------------
select *
from emp  
where job != 'SALES';    

上边就不使用索引了。
```



## 2. 结构优化

- 范式优化：消除冗余（节省空间）
- 反范式优化：适当增加冗余（减少表连接）
- 拆分表：垂直拆分，水平拆分





