# 数据库

## 存储引擎

### 概述

​	**插件式**存储引擎是MySql的重要特性。Mysql默认支持多种存储引擎，用户可以针对不同领域的数据库应用的不同需求选取合适的存储引擎，利用它们各自的特性提高应用的效率，提供灵活的存储。

​	5.5之前默认的存储引擎是MyISAM 之后默认为InnoDB
查看默认引擎 show variables like 'default_storage_engine';
查看所有引擎 show engines \G

​	我们当然可以在CREATE表的使用加上ENGINE关键字指定该表使用的引擎，也可以用ALTER 修改表的存储引擎。注意，修改存储引擎时要进行锁表和复制数据，这个操作对于线上环境的表可能很**危险**。

### 常见的几种引擎

#### 1、MyISAM
**每个MyISAM的表在磁盘上存储成三个文件**

  表名.frm：负责存储表的结构
  表名.myd：负责储存表的数据
  表名.myi：负责存储表的索引

**MyISAM表的结构还有三种形态**

静态表：默认形态，表中所有字段都是非变长，因此每条记录都是固定长度的(不够末尾要补空格)，优点是整齐，存取的时间效率很高，易于缓存和故障恢复。缺点很明显，占用的空间比其他形式要高

动态表：表中包含变长字段，记录不是固定长度的。这样的优点是占的空间相对较少，但是**频繁的更新或删除记录会带来碎片化**，需要定期OPTIMIAZW TABLE 

压缩表：只占用非常小的磁盘空间

**选取条件**

​	在某些对事务完整性没有要求，没有并发写操作的场景以SELECT和INSERT为主，UPDATE和DELETE很少的应用场景中使用MyISAM是合适的，相比InnoDB会有一定存储上的优势；

#### 2、InnoDB 

**表空间**

​	表空间是数据库划分的逻辑单位，有了表空间后，我们可以限制用户所占用的配额，控制数据库所占用的磁盘空间，还可以把不同的表放到不同表空间中方便管理。把这些限制、操作施加在表空间这个逻辑单位上，进而能管理真实的数据库。

![image-20210312182827332](%E5%B8%B8%E8%A7%81%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E.assets/image-20210312182827332.png)

InnoDB存储引擎层把16K当作最小的单元处理(下图的ibd文件大小98304也是16的倍数)，正如操作系统页面调度以4K为最小单位一样

**每个InnoDB的表在磁盘存储为两部分**

​	表的表结构依然是**.frm**文件，其他均放在表空间中,放在表空间的意思是，**生成的是.ibd文件，不是其他文件**，管理表空间就是管理它们

![image-20210312144516119](%E5%B8%B8%E8%A7%81%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E.assets/image-20210312144516119.png)

通常来说，各个表的数据和索引所处的表空间叫**多表空间**，系统文件和日志所处的表空间叫**共享表空间**

**选取条件**

   它是常见引擎中唯一支持提交回滚故障恢复等事务安全性操作的存储引擎，同时提供了更小的锁粒度和更高的并发能力，也是唯一支持外键约束的引擎。虽然比MyISAM占用更多空间，但是对CRUD所有操作都很友好，总之它适用于绝大多数的应用场景

#### 3、Memory

**每个Memory的表的存储为两部分**

​	每个使用Memory存储引擎的表只对应一个磁盘文件.frm用于存放表的结构，表的内容都存放于内存中并且默认使用HASH索引。

**选取条件**

​	它把我们所需要的数据都存放在**RAM**中，因此存取速度极快，可以在不经常修改的表中定位记录或者作为统计操作的中间结果表，便于高效地对中间结果进行分析并得到最终结果。缺陷昂贵的RAM使表的大小严重受限，太大的表无法缓存到内存中，并且掉电即使失。

#### 4、Merge

**Merge表有点类似于视图**

​	用于将一系列**结构等同**的MyISAM表以逻辑方式组合在一起，并作为一个对象引用它们，它本身并没有我们想要的记录。我们可以通过对Merge表进行CRUD影响真实的表，但DROP Merge表只是删除逻辑定义，不能删除它引用的MyISAM表。可以通过修改.mrg文件来修改Merge表

<img src="%E5%B8%B8%E8%A7%81%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E.assets/image-20210312154841457.png" alt="image-20210312154841457" style="zoom:67%;" />

<img src="%E5%B8%B8%E8%A7%81%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E.assets/image-20210312153710875.png" alt="image-20210312153710875" style="zoom:75%;" />

查询Merge表会看到它所引用的MyISAM表的结果集合，先引用的tbl_1就先展示tbl_1的结果。默认是只读的，调整为可写后的插入默认会插入到最后引用的表中

**选取条件**

优点是突破了对单个MyISAM表大小的限制。并且可以通过将不同的表分布与多个磁盘上，分散数据库的IO，提高性能。可以使用MERGE透明地对多个表进行查询和更新

​	**透明：**真实的表怎么存取的关心，用户只能看见Merge表

### 引擎所支持的索引

索引在MySql的存储引擎层实现，而不是服务器层实现，所以不同的存储引擎使用的索引可能是不同的

​	**MyISAM和InnoDB**的表默认创建的都是**BTree索引**，**MEMORY表**使用**HASH索引**，但也支持**BTree索引**

​	

## 索引

### MoocPPT

永远的神

https://nos.netease.com/edu-lesson-pdfsrc/09B89CB5D7A1E2A26A1BE6C8829A3EBA-1460763581527?download=%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%E8%AE%B2%E4%B9%89%E7%AC%AC18%E8%AE%B2%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95%E6%8A%80%E6%9C%AF.pdf&Signature=YYXRCWs8Z4HUKsFLuKlnPJs5M5s9nSEv1ZQuzYl2698%3D&Expires=1615613735&NOSAccessKeyId=7db2f370ff9a412987155d36d55a6ead

#### 概念及作用

​	**定义：**索引是建立在存储表之上，有助于无需检查所有记录而快速定位所需记录的**辅助存储结构**，由一系列索引项组成，每个索引项还分为索引字段和指针。

索引项组成的文件叫**索引文件**，存储表叫**主文件**。

**作用原理：**索引文件比主文件小很多，通过把小的索引文件装入内存进行快速定位，再有**针对性**地读取比较大的主文件中的内容。

**注意：**1、建表后如果定义了主键或者唯一性约束，系统会自动为其生成索引。

​			2、索引也可以由用户定义与撤销，但都由系统维护管理，使所有索引与主表Table保持一致。

​			3、索引是辅助存储结构，即索引随着表的变化发生变化，不会影响到主表本身；



#### 索引的分类

##### 第一种分类

<img src="%E5%B8%B8%E8%A7%81%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E.assets/image-20210313102517033.png" alt="image-20210313102517033" style="zoom:67%;" />

**稠密索引：**对于主文件对应字段的每一个不同的值都有一个索引项与它对应。即索引文件中包含了主文件对应字段的所有不同值

**稀疏索引：**对于主文件对应字段的部分不同值有索引项与它对应。即索引文件包含了仅仅包含了主文件对应字段的部分不同值

​	**稀疏索引如何定位记录**

​		搜索字段值为K的记录，要定位到小于等于K的最大字段值所在的索引项，再顺序扫描该索引项对应的存储块。**这就要求稀疏索引的主文件必须是按照索引字段排序存储的。**



##### 第二种分类

<img src="%E5%B8%B8%E8%A7%81%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E.assets/image-20210313110626453.png" alt="image-20210313110626453" style="zoom:67%;" />

**主索引：**一种稀疏索引，常常建立在基于主键**排序**的主文件的主键字段上。每一个索引项指向一个存储块，索引项的个数与表所占的块数相等。每个存储块的头一条记录的主键叫做**块锚**，索引文件是基于块锚的有序文件。

**辅助索引：**一种稠密索引，常常建立在非排序主文件的非主键字段上，每个索引项都指向一条记录，检索效率极快

​	**一张表只有一个主索引，可以有多个辅助索引**



##### 第三种分类

**聚簇索引：**索引文件中临近存储的记录在主文件中也是临近存储的。这就需要按该索引字段排序

**非聚簇索引：**索引文件中临近存储的记录在主文件中不一定是临近存储的。

​	**一张表只有一个聚簇索引，可以有多个非聚簇索引**



##### 树形索引

​	当索引项比较多时，不便于一次性装入内存，可以对索引再建立索引，依此类推，形成**多级索引**。常见的多级索引形式，如**B树/B+树索引，以树型数据结构来组织索引项。**

**每一个节点都代表了一个索引文件**

<img src="%E5%B8%B8%E8%A7%81%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E.assets/image-20210313113347092.png" alt="image-20210313113347092" style="zoom:60%;" /><img src="%E5%B8%B8%E8%A7%81%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E.assets/image-20210313113359980.png" alt="image-20210313113359980" style="zoom:45%;" />

**B Tree：**叶节点和非叶节点都有指向数据块的指针，索引字段值仅出现一次或者在叶结点或者在非叶结点，所有节点才能覆盖所有简直的索引。

**B+Tree：**非叶结点的指针指向索引块，叶结点指针指向主文件的数据块或数据记录，索引字段值重复出现于叶结点和非叶结点，所有叶子节点即可覆盖所有键值的索引

B+Tree成了数据库系统实现索引的**首选数据结构**，这是因为：

1、相比于B树，非叶子节点不必指向数据块，可以指向更多的节点，让树型变得更宽更低，降低磁盘IO次数。

2、所有叶子节点通过指针串联了起来，支持顺序扫描。



**MyISAM引擎和InnoDB引擎都默认使用BTtree(B+树)** ，但还有一定区别

前者是数据和索引是分别位于**.myd**和**.myi**文件，后者的数据和索引都在**.idb**文件中。

<img src="%E5%B8%B8%E8%A7%81%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E.assets/image-20210313115246425.png" style="zoom:80%;" />

<img src="%E5%B8%B8%E8%A7%81%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E.assets/image-20210313115227893.png" alt="image-20210313115227893" style="zoom:80%;" />

##### 散列索引

​	将索引字段的值作为参数给到散列函数，**计算**出对应的桶号，即找到了记录所在的存储块，再在存储块中**顺序扫描**。是一种速度非常快的搜索方式。

散列索引可以分为**静态散列和动态散列**。静态散列的桶数固定，会占用不小空间。动态散列的桶数随数据量而定，比较灵活。

​	由于利用Hash函数存储时记录具有**无序性**，因此非常适合也只能用于=或<>的**等值(K-V)查询**中，不能用在任何范围性的查询如 ">",BETWEEN AND,ORDER BY等操作中。实际上当后者启动查询时，Hash索引根本不生效，会全表扫描。**Memory表**在查询时，要注意Sql的写法，尽可能地使用上索引，如果不得不进行**范围查询**，应该在建立索引时选择BTree索引



### 索引设计原则

1、选取最常出现在WHERE子句，连接子句中的字段。要考虑字段中值的分布，基数越大，**选择度**越高，索引效果越好。

**性别字段的基数很小，选择度很低。身份证字段的基数很大，选择度很高**

2、尽量使用**短索引**，对字符串进行检索时，指定一个前缀长度。较短的索引涉及的磁盘IO次数更少，每个磁盘数据块也能容纳更多的索引，提高索引的缓存效果。

3、**数据量**很小的表，索引扫描和全表扫描相比没有大幅提升，因此添加除了主键以外的索引没有太大意义。数据量庞大的表则必须避免全表扫描，需要添加索引。

4、每个索引都要占用额外空间，降低写的性能。**修改表内容时，索引也要跟着修改甚至重构**，因此加的索引越多越耗时。只保持必须的索引有利于查询优化

### 











