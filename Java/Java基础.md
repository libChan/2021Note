## Java基础

*最近在跟 [JavaGuide](https://github.com/Snailclimb/JavaGuide)系统学一遍 Java，这是基础部分，只简要记录。*

### 概念

#### JDK和JRE

JDK(Java Development Kit)，是功能齐全的 Java SDK。**它拥有 JRE 所拥有的一切**，还有编译器（javac）和工具（如 javadoc 和 jdb）。它**能够创建和编译程序**。

**JRE 是 Java 运行时环境**。它是运行已编译 Java 程序所需的所有内容的集合，包括 Java 虚拟机（JVM），Java 类库，java 命令和其他的一些基础构件。**但是，它不能用于创建新程序。**

#### Java和C++的区别

- Java不提供指针来直接访问内存，程序内存更加安全。
- Java 的类是单继承的，C++ 支持多重继承；虽然 Java 的类不可以多继承，但是接口可以多继承。==*详细了解*==
- Java 有自动内存管理垃圾回收机制(GC)，不需要程序员手动释放无用内存
- **在 C 语言中，字符串或字符数组最后都会有一个额外的字符`'\0'`来表示结束。但是，Java 语言中没有结束符这一概念。** 这是一个值得深度思考的问题，具体原因推荐看这篇文章：[java与C语言在字符串结束符上的区别](https://blog.csdn.net/sszgg2006/article/details/49148189)。==*这个问题非常有意思，实践也蛮有用。*==

#### 编译语言与解释语言

由 Java 编写的程序需要先经过编译步骤，生成字节码（*.class 文件），这种字节码必须由 Java 解释器来解释执行。因此，我们可以认为 Java 语言编译与解释并存。

==展开了解==

#### 基本数据类型

- Java 里使用 long 类型的数据一定要在数值后面加上 **L**，否则将作为整型解析。
- **Java 基本类型的包装类的大部分都实现了==常量池技术==，即 Byte,Short,Integer,Long,Character,Boolean；前面 4 种包装类默认创建了数值[-128，127] 的相应类型的缓存数据，Character 创建了数值在[0,127]范围的缓存数据，Boolean 直接返回 True Or False。如果超出对应范围仍然会去创建新的对象。** 为啥把缓存设置为[-128，127]区间？（[参见 issue/461](https://github.com/Snailclimb/JavaGuide/issues/461)）性能和资源之间的权衡。**两种浮点数类型的包装类 Float,Double 并没有实现常量池技术。**

1. Integer i1=40；Java 在编译的时候会直接将代码封装成 Integer i1=Integer.valueOf(40);，从而使用常量池中的对象。
2. Integer i1 = new Integer(40);这种情况下会创建新的对象。

- 拆箱：将包装类型转换为基本数据类型；

  装箱：将基本类型用它们对应的引用类型包装起来；

<img src="./img/1" alt="img" style="zoom:67%;" />

#### ==和equals()

**基本数据类型`==`比较的是值，引用数据类型`==`比较的是内存地址。**

`equals()`是类比较方法，可自定义重写比较。

#### hashCode()与 equals()

`hashCode()`定义在 JDK 的 `Object` 类中，`Object` 的`hashCode()`是本地方法，用 c/c++ 实现，该方法通常用来将对象的`内存地址`转换为整数之后返回（相当于==），所以比较类对象要重写`equal()`和`hashCode()`。

- 两个对象的hashcode相同，但其实不一定”相等“，散列可能发生碰撞？

[Java hashCode() 和 equals()的若干问题解答](https://www.cnblogs.com/skywang12345/p/3324958.html)

#### Java只有值传递

C++中有值传递和引用传递，值传递传入值，引用传递传入地址。

**Java 程序设计语言对对象采用的不是引用调用，实际上，对象引用是按值传递的。**

下面再总结一下 Java 中方法参数的使用情况：==这里有点抽象不完全理解==

- 一个方法不能修改一个基本数据类型的参数（即数值型或布尔型）。
- 一个方法可以改变一个对象参数的状态。
- 一个方法不能让对象参数引用一个新的对象。

#### 重载与重写

**重载：**同样的一个方法能够根据输入数据的不同（参数个数，参数类型，参数顺序，返回值，访问修饰符），做出不同的处理。

**重写：**当子类继承自父类的相同方法，输入数据一样，但要做出有别于父类的响应时，就要覆盖父类方法。

1. 返回值类型、方法名、参数列表必须相同，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。
2. 如果父类方法访问修饰符为 `private/final/static` 则子类就不能重写该方法，但是被 static 修饰的方法能够被再次声明。
3. 构造方法无法被重写。
4. 如果方法的返回类型是void和基本数据类型，则返回值重写时不可修改。但是如果方法的返回值是引用类型，重写时是可以返回该引用类型的子类的。

#### 深拷贝和浅拷贝

1. **浅拷贝**：对基本数据类型进行值传递，对引用数据类型进行引用传递般的拷贝，此为浅拷贝。
2. **深拷贝**：对基本数据类型进行值传递，对引用数据类型，**创建一个新的对象，并复制其内容，**此为深拷贝。

![deep and shallow copy](./img/2.jpg)

------



## Java面向对象

**面向对象三大特征：封装，继承，多态。**

- **面向过程** ：**面向过程性能比面向对象高。** 因为类调用时需要实例化，开销比较大，比较消耗资源，所以当性能是最重要的考量因素的时候，比如单片机、嵌入式开发、Linux/Unix 等一般采用面向过程开发。
- **面向对象** ：**面向对象易维护、易复用、易扩展。** 因为面向对象有封装、继承、多态性的特性，所以可以设计出低耦合的系统，使系统更加灵活、更加易于维护。但是，**面向对象性能比面向过程低**。

#### 父类中没有参数的构造方法

Java 程序在执行子类的构造方法之前，如果没有用 `super()`来调用父类特定的构造方法，则会调用父类中“没有参数的构造方法”。所以父类中需要一个这样的构造器，否则容易在子类中bug。

#### 成员变量、局部变量

1. 如果成员变量是使用`static`修饰的，该成员变量是属于类的，如果没有`static`修饰，这个成员变量是属于实例的。**对象存在于堆内存，局部变量则存在于栈内存。**
2. 成员变量如果没有被赋初值，则会自动以类型的默认值而赋值（一种情况例外：被 final 修饰的成员变量也必须显式地赋值），而局部变量则不会自动赋值。

#### 对象和对象引用

- **对象实例在堆内存中，对象引用指向对象实例（对象引用存放在栈内存中）。一个对象引用可以指向 0 个或 1 个对象，一个对象可以有 n 个引用指向它。**

- **对象的相等，比的是内存中存放的内容是否相等。而引用相等，比较的是他们指向的内存地址是否相等。**

#### 多态

==多态不熟悉，展开了解==

多态，顾名思义，表示一个对象具有多种的状态。具体表现为父类的引用指向子类的实例。

**多态的特点:**

- 对象类型和引用类型之间具有继承（类）/实现（接口）的关系；
- 引用类型变量发出的方法调用的到底是哪个类中的方法，必须在程序运行期间才能确定；
- 多态不能调用“只在子类存在但在父类不存在”的方法；
- 如果子类重写了父类的方法，真正执行的是子类覆盖的方法，如果子类没有覆盖父类的方法，执行的是父类的方法。

#### String、StringBuilder、StringBuffer

- String不可变（final char[])，后两者采用char[]存（Java 9后采用byte[]存）。
- StringBuilder线程不安全，StringBuffer线程安全。

1. 操作少量的数据: 适用 `String`
2. **单线程**操作字符串缓冲区下操作大量数据: 适用 `StringBuilder`
3. 多线程操作字符串缓冲区下操作大量数据: 适用 `StringBuffer`

#### 异常

![img](./img/Java异常类层次结构图.png)

- **`try`块：** 用于捕获异常。其后可接零个或多个 `catch` 块，如果没有 `catch` 块，则必须跟一个 `finally` 块。
- **`catch`块：** 用于处理 try 捕获到的异常。
- **`finally` 块：** 无论是否捕获或处理异常，`finally` 块里的语句都会被执行。当在 `try` 块或 `catch` 块中遇到 `return` 语句时，`finally` 语句块将在方法返回之前被执行。 当 try 语句和 finally 语句中都有 return 语句时，在方法返回之前，finally 语句的内容将被执行，并且 finally 语句的返回值将会覆盖原始的返回值。

**在以下 3 种特殊情况下，`finally` 块不会被执行：**

1. 在 `try` 或 `finally `块中用了 `System.exit(int)`退出程序。但是，如果 `System.exit(int)` 在异常语句之后，`finally` 还是会被执行。
2. 程序所在的线程死亡。
3. 关闭 CPU。

面对必须要关闭的资源，我们总是应该优先使用 `try-with-resources` 而不是`try-finally`。



==反射，文件I/O，多线程没有记录，这部分后面展开。==