# 传输层

## 1. 概述

传输层是提供**应用进程间的逻辑通信服务**，向应用层屏蔽了下面的网络细节（网络拓扑，路由选择协议等），使应用程序看起来像是在两个传输层实体之间有一条端到端的逻辑通信信道。

[敖丙用近 40 张图解被问千百遍的 TCP 三次握手和四次挥手面试题](https://mp.weixin.qq.com/s/rX3A_FA19n4pI9HicIEsXg)

## 2. TCP(传输控制协议)

### 2.1 TCP特点

- 面向连接
- 一对一
- 可靠传输
- 全双工
- 面向字节流：应用层传下来的报文看成字节流，把字节流阻止成大小不等的数据块。

### 2.2 TCP报文段格式

<img src="./img/4.jpg" alt="TCP报文段格式" style="zoom:50%;" />

- **序列号(seq number)**：**指发送数据的位置。**每发送一次就累加一次数据字节数的大小。序列号是在建立连接时由计算机生成的随机数作为初始值，通过SYN包传给接收端主机。
- **确认号(ack number)**：**下一次应该收到的数据的序列号。**它指已收到`确认号-1`为止的数据。这个序号以前的数据都被正常接收。
- 数据偏移(offset)：数据部分从哪个位开始计算。
- 控制位：从左到右为CWR, ECE, URG, ACK, PSH, SYN, FIN。
- 窗口大小：通知能接收数据大小。
- 校验和

### 2.3 TCP三次握手

<img src="./img/5.jpg" alt="TCP三次握手" style="zoom:50%;" />

1. B处于LISTEN（监听）状态，等待客户端的连接请求。
2. A向B发送连接请求报文(**SYN**)：SYN=1，ACK=0，seq=x（随机指定）。
3. B收到连接请求报文(**SYN-ACK**)：同意连接则向A发送连接确认报文：SYN=1, ACK=1, seq=y（随机指定），ack = x+1。
4. A收到B的连接确认报文后，向B发出确认(**ACK**)：ACK = 1, seq = x+1, ack = y+1。
5. B收到A的确认后，连接建立。

#### Q: TCP为什么3次握手？

可靠传输，需要让双方都分别确认自己的收发与对方的收发是正确可靠的。如下表，Client(S)表示客户端视角看服务器：

- 第一次客户端->服务器，C确认：C发送ok，S确认：S接收ok，C发送ok。
- 第二次服务器->客户端，S确认：S发送ok，C确认：C接收ok，S发送ok，S接收ok。
- 第三次客户端->服务器：S确认：C接收ok。

以上，3次握手让双方都确认自己与对方的发送接收可靠正常，才能建立连接。

|      | Client(C) | Client(C) | Client(S) | Client(S) | Server(C) | Server(C) | Server(S) | Server(S) |
| ---- | --------- | --------- | --------- | --------- | --------- | --------- | --------- | --------- |
|      | send      | receive   | send      | receive   | send      | receive   | send      | receive   |
| 1    | √         |           |           |           | √         |           |           | √         |
| 2    |           | √         | √         | √         |           |           | √         |           |
| 3    |           |           |           |           |           | √         |           |           |

TCP 建立连接时，通过三次握手**能防止历史连接的建立，能减少双方不必要的资源开销，能帮助双方同步初始化序列号**。序列号能够保证数据包不重复、不丢弃和按序传输。比如，客户端连续发送多次 SYN 建立连接的报文，在网络拥堵等情况下：

- 一个「旧 SYN 报文」比「最新的 SYN 」 报文早到达了服务端；
- 那么此时服务端就会回一个 `SYN + ACK` 报文给客户端；
- 客户端收到后可以根据自身的上下文，判断这是一个历史连接（序列号过期或超时），那么客户端就会发送 `RST` 报文给服务端，表示中止这一次连接。

**不使用「两次握手」和「四次握手」的原因：**

- 「两次握手」：无法防止历史连接的建立，会造成双方资源的浪费，也无法可靠的同步双方序列号；
- 「四次握手」：三次握手就已经理论上最少可靠连接建立，所以不需要使用更多的通信次数。

#### Q: 什么是半连接队列？

> 服务器第一次收到客户端的 SYN 之后，就会处于 SYN_RCVD 状态，此时双方还没有完全建立其连接，服务器会把此种状态下请求连接放在一个队列里，我们把这种队列称之为半连接队列。
>
> 当然还有一个全连接队列，就是已经完成三次握手，建立起连接的就会放在全连接队列中。如果队列满了就有可能会出现丢包现象。

#### Q: ISN是什么？是固定的吗？为什么动态随机？

ISN(Initial Sequence Number)指发送方字节数据编号的原点，让对方生成一个合法的接收窗口。

ISN是动态随机的（随时间变化），为了防止在网络中被延迟的分组以后又被传送，而导致接收方解析错误。

动态随机随机导致每个tcp会话里的seq号没有重叠。

#### Q: 三次握手过程中可以携带数据吗？

> 其实第三次握手的时候，是可以携带数据的。但是，**第一次、第二次握手不可以携带数据**。
>
> 为什么这样呢?大家可以想一个问题，假如第一次握手可以携带数据的话，如果有人要恶意攻击服务器，那他每次都在第一次握手中的 SYN 报文中放入大量的数据。因为攻击者根本就不理服务器的接收、发送能力是否正常，然后疯狂着重复发 SYN 报文的话，这会让服务器花费很多时间、内存空间来接收这些报文。
>
> 也就是说，第一次握手不可以放数据，其中一个简单的原因就是会让服务器更加容易受到攻击了。而对于第三次的话，此时客户端已经处于 ESTABLISHED 状态。对于客户端来说，他已经建立起连接了，并且也已经知道服务器的接收、发送能力是正常的了，所以能携带数据也没啥毛病。

### 2.4 TCP四次挥手

<img src="./img/6.jpg" alt="image-20210317170949386" style="zoom:60%;" />

- A发送FIN（连接释放报文），seq = u, A处于FIN-WAIT-1状态
- B收到FIN，发送ACK，ack=u+1，seq=v，B处于CLOSE_WAIT状态。**此时TCP处于半关闭状态**，客户端到服务端的连接释放，客户端收到ACK报文后，进入FIN-WAIT-2状态。
- B发送FIN（连接释放报文），seq=w，ack = u+1,  B进入LAST-ACK状态。
- A收到FIN后，发送ACK作为应答，seq = u+1,  ack=w+1，然后A处于TIME-WAIT状态，过一段时间（2MSL）才进入CLOSED状态，B收到ACK后进入CLOSED状态。

#### Q: 为什么需要4次挥手？

> 因为当服务端收到客户端的FIN连接请求报文后，可以直接发送FIN+ACK报文。其中ACK报文是用来应答的，FIN报文是用来同步的。但是关闭连接时，当服务端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉客户端，“你发的FIN报文我收到了”。只有等到我服务端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四次挥手。

#### Q: 四次挥手释放连接时，等待2MSL的意义?

MSL是最长报文段寿命，超过这个时间报文将被丢弃。

- **让服务器正常关闭：**服务器向客户端发FIN后等待客户端的ACK，如果客户端的ACK丢失，服务器一直接收不到，服务器会超时重传FIN，客户端再重传ACK，重启计时器。如果客户端发完ACK后直接关闭，一旦ACK丢失，服务器就无法正常关闭。2MSL保证了客户端的ACK服务器收到了。

- **防止旧连接的报文干扰：**假设立马断开连接，但是又重用了这个连接，就是五元组完全一致，并且序号还在合适的范围内，虽然概率很低但理论上也有可能，那么新的连接会被已关闭连接链路上的一些残留数据干扰，因此给予一定的时间来处理一些残留数据。

#### Q: 大量连接处于TIME_WAIT或者CLOSE_WAIT状态？

**大量TIME_WAIT：**客户端会处于TIME_WAIT状态（2MSL），因为连接太多，可分配fd被占用完了，无法建立新的TCP连接，情况不是很严重，可以等待超时自动关闭，也可以调整网络参数，重用处于TIME_WAIT的TCP连接等等。**要么就是对方连接的异常，要么就是自己没有迅速回收资源**，总之不是由于自己程序错误导致的。

如果你的服务器是HTTP服务器，那么可以设置一个HTTP的keep-alive，它可以保证一次http请求完毕后，不断开tcp连接，这样就可以重用一个TCP连接来处理多个HTTP请求，然后让客户端去断连，TIME_WAIT就不在服务器这边了。

**大量CLOSE_WAIT：**服务端收到FIN后没有发出FIN+ACK，导致连接被搁置，查为什么没有发出FIN+ACK，查代码。

### 2.5 TCP流量控制

**流量控制：**防止发送方发的太快了，来不及接收处理，是一个速度匹配服务。

TCP连接是全双工的，双方各自维护一个接收窗口，接收窗口值放入TCP头部的rwnd字段，通知对方。如果接收端发现缓冲区满了，会将窗口大小设置为0，发送端即停止发送数据，但发送端需要定期发送窗口探测数据段（一个字节），使接收端把窗口大小告诉发送端。

**Q：如果接收端的窗口每次回复的值都很小怎么办？**

**发送端调整：**当接收端窗口大于阈值(MSS)再发，攒着。**接收端调整：**窗口小于一个阈值就不告诉发送端，同时搭配延迟确认，会等之后的包确认了再发送确认。

### 2.6 TCP拥塞控制

**拥塞控制：**防止发送方发的太快，网络来不及处理，导致网络链路拥塞。

**丢包：**超时，或者收到来自接收方的3个冗余ACK。

发送端维护一个拥塞窗口(cwnd)，控制向网络中发送流量的速率。

发送方：未确认的数据量$$<=min\{rwnd, cwnd\}$$

**TCP拥塞控制算法：**

**慢启动：**最初设置cwnd为1，每次收到确认ACK后，将cwnd翻倍，1, 2, 4, 8......。翻倍增长会让cwnd指数级增长，设置阈值ssthresh（初始值16），**当rwnd =ssthresh，转为拥塞避免。**

**拥塞避免：**每经过一个RTT，cwnd+1。如果发生**超时重传**，将阈值设置为cwnd/2，cwnd=1，进入新的慢启动。如果发生**快速重传**，在**TCP Tahoe**，和超时重传一样，又进入慢启动；在 **TCP Reno**中，是把 cwnd = cwnd/2 ，然后ssthresh 设置为当前的 cwnd ，进入快速恢复阶段。

**快速恢复：**在TCP Reno中

1. cwnd = sshthresh + 3 * MSS （3的意思是假设有3个数据包被收到了）
2. 重传duplicated ACKs指定的数据包
3. 如果再收到 duplicated Acks，那么cwnd = cwnd +1
4. 如果收到了新的Ack，那么，cwnd = sshthresh ，然后就进入了拥塞避免的算法了。

1-3阶段是cwnd膨胀阶段，用于快速恢复到正常情况，第4阶段认为已经正常了，无需快速恢复，因此cwnd进行了收缩。

TCP Reno的问题在于它依赖于3个重复的Acks。注意，3个重复的Acks并不代表只丢了一个数据包，很有可能是丢了好多包。但**这个算法只会重传一个**，而剩下的那些包只能等到RTO超时，于是，进入了恶梦模式——超时一个窗口就减半一下，多个超时会超成TCP的**传输速度呈级数下降**。

**TCP New Reno：**

New Reno是在没有SACK 的情况下改进快速恢复，它会观察重传 Duplicate ACK 指定的包的响应 ACK 是否是已经发送的最大 ACK。比如你发了1、2、3、4，对方没收到 2，但是 3、4都收到了，于是你重传 2 之后 ACK 肯定是 5，说明就丢了这一个包。

不然就是还有其他包丢了，如果就丢了一个包就是之前的过程一样，如果还有其他包丢了就继续重传，直到 ACK 是全部的之后再退出快速恢复阶段。

简单的说就是一直探测到全部包都收到了再结束这个环节。

### 2.7 TCP保活机制

定义一个时间段，在这个时间段内，如果没有任何连接相关的活动，TCP 保活机制会开始作用，每隔一个时间间隔，发送一个探测报文，该探测报文包含的数据非常少，如果连续几个探测报文都没有得到响应，则认为当前的 TCP 连接已经死亡，系统内核将错误信息通知给上层应用程序。

- tcp_keepalive_time=7200：表示保活时间是 7200 秒（2小时），也就 2 小时内如果没有任何连接相关的活动，则会启动保活机制。

- tcp_keepalive_intvl=75：表示每次检测间隔 75 秒；
- tcp_keepalive_probes=9：表示检测 9 次无响应，认为对方是不可达的，从而中断本次的连接。

**也就是说在 Linux 系统中，最少需要经过 2 小时 11 分 15 秒才可以发现一个「死亡」连接。**

**如果开启了 TCP 保活，需要考虑以下几种情况：**

**1、对方是正常工作的。**当 TCP 保活的探测报文发送给对端, 对端会正常响应，这样 **TCP 保活时间会被重置**，等待下一个 TCP 保活时间的到来。

**2、对方崩溃并重启。**当 TCP 保活的探测报文发送给对端后，对端是可以响应的，但由于没有该连接的有效信息，**会产生一个 RST 报文**，这样很快就会发现 TCP 连接已经被重置。

**3、对方崩溃，或由于其他原因导致报文不可达。**当 TCP 保活的探测报文发送给对端后，石沉大海，没有响应，连续几次，达到保活探测次数后，**TCP 会报告该 TCP 连接已经死亡**。

### 2.8 TCP常见问题

**Q：如何解决TCP粘包问题？**

首先这不应该是TCP的问题，TCP是流式协议，所谓“包”应该是上层协议的概念和任务。**TCP是面向字节流的协议而不是消息包的，会把字节流可靠的送到，但需要上层协议去做字节流解析。**

粘包：比如客户端向服务端两次发送，分别是包A和B，服务端一次读取，把A和B“粘”在一起读了出来。

**所以这其实是上层协议如何识别边界的问题：**

1. **约定包长的数据包**：简单但灵活性差。
2. **以指定字符（串）为包的结束标志**：比较常见，例如FTP或者邮件FMTP用\r\n结尾。问题是，需要对包内原本的\r\n进行转义，避免接收端误认为是包结束符。
3. **包头+包体格式：**另搞个包头描述该收多少。

例如，send是将字节存放在缓冲区，并不代表这些内容以一个“包”的形式就发出去了，具体要看TCP的实现，可能缓冲区满了才发送一次。

**Q：为什么需要快速重传？超时重传不可以吗？**

**超时重传**的时间计算有很多动态算法，**适用于网络真的不好时**。**快速重传适用于网络状况还可以，只是碰巧包丢了**，收到3个重复ACK表明网络还可以，那么立刻重传。**快速重传哪些包呢？**

1. SACK，接收方会告诉发送方哪些字节我收到了，发送方重传没收到的即可。
2. D-SACK，SACK的扩展，接收方会用SACK的第一个范围描述哪些报文被重复接收了，好处：可以让发送方知道，是发出去的包丢了，还是回来的ACK包丢了？是不是自己的timeout太小了，导致重传？网络上出现了先发的包后到的情况（又称reordering）？网络上是不是把我的数据包给复制了？

知道这些东西可以很好得帮助TCP了解网络情况，从而可以更好的做网络上的流控。

## 3. UDP(用户数据报协议)

### 3.1 UDP特点

- 无连接
- 尽最大可能交付
- 无拥塞控制
- 面向报文（对应用层的报文不合并不拆分，只添加UDP首部）
- 一对一、一对多、多对一

### 3.2 UDP报文格式

![UDP报文格式](/img/7.jpg)

应用场景：

- 包总量少的通信
- 视频、音频多媒体即时通信
- 广播、多播

## 4. GBN和SR

### 4.1 GBN(滑动窗口协议)

**滑动窗口：**如果每发送一个数据段，等一个ACK，再发下一个，串行的话性能较差。**使用滑动窗口，可以一次发多条数据，是服务器端告诉发送端窗口缓冲区的大小（字节）。**

### 4.2 SR(选择重传协议)



## 参考

[面试官，不要再问我三次握手和四次挥手 - 老刘的文章 - 知乎]( https://zhuanlan.zhihu.com/p/86426969)

[万字长文 | 23 个问题 TCP 疑难杂症全解析](https://mp.weixin.qq.com/s/LUtk6u_zv0w8g8GIGWEuCw)
